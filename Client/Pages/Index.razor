@page "/"
@inject HttpClient Http
@inject IJSRuntime Js

<PageTitle>SpeechInsight - Upload &amp; Analyze</PageTitle>

<h1>SpeechInsight</h1>
<p>Upload an audio file to transcribe.</p>

<div class="upload-row">
    <InputFile OnChange="OnFileSelected" accept=".mp3,.mpga,.m4a,.wav,.webm,.mp4,.mpeg,audio/*" />
    @if (_selectedFile != null)
    {
        <span class="file-info">@_selectedFile.Name (@FormatFileSize(_selectedFile.Size))</span>
    }
</div>
@if (!string.IsNullOrEmpty(_fileValidationError))
{
    <p class="error">@_fileValidationError</p>
}

<div class="model-row">
    <label for="model-select">Model:</label>
    <select id="model-select" value="@_modelChoice" @onchange="OnModelChanged" disabled="@_isUploading">
        <option value="diarize">With speakers (recommended)</option>
        <option value="basic">Basic (Whisper — cheaper)</option>
    </select>
</div>
<p class="cost-hint">Basic is cheaper; “With speakers” uses a more capable model and may cost more per minute.</p>

<div class="button-row">
    <button type="button" @onclick="HandleSubmit" disabled="@(_isUploading || _selectedFile == null)">Upload and Analyze</button>
    @if (_isUploading)
    {
        <button type="button" class="cancel" @onclick="CancelUpload">Cancel</button>
    }
</div>
@if (_selectedFile == null)
{
    <p class="hint">Select an audio file to enable upload.</p>
}

@if (_isUploading || !string.IsNullOrEmpty(_loadingStatus))
{
    <div class="loading-box" role="status" aria-live="polite">
        <div class="spinner"></div>
        <span class="loading-text">@(_loadingStatus ?? "Uploading…")</span>
    </div>
}

@if (_durationExceedsRecommended)
{
    <p class="warning">This clip is longer than the recommended limit. For long files, consider splitting or using shorter segments.</p>
}

<div id="transcription-result">
@if (_stats != null)
{
    <h2>Stats</h2>
    <div class="stats-cards">
        <div class="stat-card"><span class="stat-label">Duration</span><span class="stat-value">@(_stats.DurationSeconds.HasValue ? $"{_stats.DurationSeconds:F1}s" : "—")</span></div>
        <div class="stat-card"><span class="stat-label">Words</span><span class="stat-value">@_stats.WordCount</span></div>
        <div class="stat-card"><span class="stat-label">Characters</span><span class="stat-value">@_stats.CharCount</span></div>
        <div class="stat-card"><span class="stat-label">Segments</span><span class="stat-value">@_stats.SegmentCount</span></div>
        <div class="stat-card"><span class="stat-label">Model</span><span class="stat-value stat-model">@_stats.Model</span></div>
    </div>
}

@if (!string.IsNullOrEmpty(_transcription))
{
    <h2>Transcription</h2>
    <div class="transcript-container">
        <div class="transcript-inner">
            @foreach (var block in GetTranscriptBlocks())
            {
                if (block.Speaker != null)
                {
                    <span class="speaker-label">@block.Speaker:</span><span class="transcript-text">@block.Text</span>
                }
                else
                {
                    <span class="transcript-text">@block.Text</span>
                }
                <br />
            }
        </div>
    </div>

    <div class="actions">
        <button type="button" @onclick="CopyTranscript" disabled="@_isUploading">Copy</button>
        <button type="button" @onclick="DownloadTxt" disabled="@_isUploading">Download .txt</button>
        <button type="button" @onclick="DownloadJson" disabled="@(_isUploading || _details == null)">Download .json</button>
    </div>
    @if (!string.IsNullOrEmpty(_actionHint))
    {
        <div class="hint @(_actionHint.StartsWith("Copied") ? "copy-success" : "")">@_actionHint</div>
    }
}
</div>

@if (!string.IsNullOrEmpty(_error))
{
    <div class="error-box" role="alert">
        <strong>Something went wrong</strong><br />@_error
    </div>
}

@if (_history.Count > 0)
{
    <h2>Recent</h2>
    <p class="hint">Saved in this browser. Click a file to view again.</p>
    <ul class="history-list">
        @foreach (var h in _history)
        {
            <li>
                <button type="button" class="link-btn" @onclick="() => RestoreHistory(h)">@h.FileName</button>
                — @(h.DurationSeconds.HasValue ? $"{h.DurationSeconds:F0}s" : "—") · @h.WordCount words
            </li>
        }
    </ul>
    <button type="button" class="clear-history" @onclick="ClearHistoryAsync">Clear recent</button>
}

@code {
    private const long MaxFileSizeBytes = 25 * 1024 * 1024;
    private const string HistoryStorageKey = "SpeechInsight_Recent";
    private const string ModelStorageKey = "SpeechInsight_Model";
    private static readonly string[] AllowedExtensions = { ".mp3", ".mpga", ".m4a", ".wav", ".webm", ".mp4", ".mpeg" };
    private static readonly System.Text.Json.JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase
    };

    private IBrowserFile? _selectedFile;
    private string? _transcription;
    private string? _error;
    private string? _fileValidationError;
    private bool _isUploading;
    private string _modelChoice = "diarize";
    private bool _diarize => _modelChoice == "diarize";
    private bool _durationExceedsRecommended;
    private StatsView? _stats;
    private TranscriptionDetailsView? _details;
    private string? _actionHint;
    private readonly List<HistoryEntry> _history = new();
    private CancellationTokenSource? _uploadCts;
    private string? _loadingStatus;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var savedModel = await Js.InvokeAsync<string?>("speechInsight.getLocalStorage", ModelStorageKey);
            if (savedModel == "basic" || savedModel == "diarize")
                _modelChoice = savedModel;
        }
        catch { /* ignore */ }

        try
        {
            var json = await Js.InvokeAsync<string?>("speechInsight.getLocalStorage", HistoryStorageKey);
            if (string.IsNullOrWhiteSpace(json)) return;

            var stored = System.Text.Json.JsonSerializer.Deserialize<List<StoredHistoryItem>>(json, JsonOptions);
            if (stored == null) return;

            _history.Clear();
            foreach (var item in stored.Take(3))
            {
                if (item.Details == null) continue;
                _history.Add(new HistoryEntry(
                    item.FileName ?? "Unknown",
                    item.DurationSeconds,
                    item.WordCount,
                    item.Transcription ?? "",
                    item.Details));
            }
        }
        catch
        {
            // Ignore corrupt or missing localStorage
        }
    }

    private async Task OnModelChanged(ChangeEventArgs e)
    {
        var value = e.Value?.ToString();
        if (value == "basic" || value == "diarize")
        {
            _modelChoice = value;
            try
            {
                await Js.InvokeVoidAsync("speechInsight.setLocalStorage", ModelStorageKey, value);
            }
            catch { /* ignore */ }
        }
    }

    private void OnFileSelected(InputFileChangeEventArgs e)
    {
        _selectedFile = e.File;
        _error = null;
        _fileValidationError = null;
        _transcription = null;
        _stats = null;
        _details = null;
        _actionHint = null;

        if (_selectedFile == null) return;

        var ext = System.IO.Path.GetExtension(_selectedFile.Name);
        if (string.IsNullOrEmpty(ext) || !AllowedExtensions.Contains(ext, StringComparer.OrdinalIgnoreCase))
        {
            _fileValidationError = "Please choose an audio file (e.g. MP3, WAV, M4A). Max size: 25 MB.";
            _selectedFile = null;
            return;
        }
        if (_selectedFile.Size > MaxFileSizeBytes)
        {
            _fileValidationError = "File is too large. Maximum size is 25 MB.";
            _selectedFile = null;
            return;
        }
    }

    private IEnumerable<(string? Speaker, string Text)> GetTranscriptBlocks()
    {
        if (string.IsNullOrEmpty(_transcription)) yield break;
        var paragraphs = _transcription!.Split("\n\n", StringSplitOptions.None);
        foreach (var p in paragraphs)
        {
            var trimmed = p.Trim();
            if (string.IsNullOrEmpty(trimmed)) continue;
            var colon = trimmed.IndexOf(": ", StringComparison.Ordinal);
            if (colon > 0 && trimmed.StartsWith("Speaker ", StringComparison.OrdinalIgnoreCase))
            {
                var speaker = trimmed[..colon];
                var text = trimmed[(colon + 2)..].Trim();
                yield return (speaker, text);
            }
            else
            {
                yield return (null, trimmed);
            }
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / (1024.0 * 1024.0):F1} MB";
    }

    private async Task HandleSubmit()
    {
        if (_selectedFile == null)
        {
            _error = "Please select an audio file first.";
            return;
        }

        _error = null;
        _fileValidationError = null;
        _transcription = null;
        _stats = null;
        _details = null;
        _actionHint = null;
        _durationExceedsRecommended = false;
        _uploadCts = new CancellationTokenSource();
        _isUploading = true;
        _loadingStatus = "Uploading…";
        StateHasChanged();

        _ = Task.Run(async () =>
        {
            await Task.Delay(1600);
            await InvokeAsync(() =>
            {
                if (_isUploading && _loadingStatus == "Uploading…")
                {
                    _loadingStatus = "Transcribing…";
                    StateHasChanged();
                }
            });
        });

        try
        {
            using var content = new MultipartFormDataContent();
            var stream = _selectedFile.OpenReadStream(maxAllowedSize: MaxFileSizeBytes);
            await using var _ = stream;
            content.Add(new StreamContent(stream), "audioFile", _selectedFile.Name);

            var endpoint = $"api/audio/analyze/details?diarize={(_modelChoice == "diarize").ToString().ToLowerInvariant()}";
            var response = await Http.PostAsync(endpoint, content, _uploadCts.Token);

            if (response.IsSuccessStatusCode)
            {
                _loadingStatus = "Done";
                StateHasChanged();

                var details = await response.Content.ReadFromJsonAsync<TranscriptionDetailsView>(
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                if (details == null)
                {
                    _error = "The server returned an unexpected response. Please try again.";
                    _loadingStatus = null;
                    return;
                }

                _details = details;
                _transcription = FormatTranscript(details);
                _stats = BuildStats(details);
                _durationExceedsRecommended = details.DurationExceedsRecommended;

                _history.Insert(0, new HistoryEntry(
                    _selectedFile.Name,
                    details.DurationSeconds,
                    _stats.WordCount,
                    _transcription,
                    details));
                while (_history.Count > 3) _history.RemoveAt(_history.Count - 1);
                await PersistHistoryAsync();

                await Task.Delay(400);
                _loadingStatus = null;
                try { await Js.InvokeVoidAsync("speechInsight.scrollToId", "transcription-result"); } catch { /* ignore */ }
            }
            else
            {
                var body = await response.Content.ReadAsStringAsync();
                _error = ParseErrorMessage(response.StatusCode, body);
            }
        }
        catch (OperationCanceledException)
        {
            _error = "Upload was cancelled.";
        }
        catch (Exception ex)
        {
            _error = "Upload failed. Please check your connection and try again. " + ex.Message;
        }
        finally
        {
            _isUploading = false;
            _uploadCts = null;
            if (_loadingStatus == "Uploading…" || _loadingStatus == "Transcribing…")
                _loadingStatus = null;
            StateHasChanged();
        }
    }

    private void CancelUpload()
    {
        _uploadCts?.Cancel();
    }

    private static string ParseErrorMessage(System.Net.HttpStatusCode status, string body)
    {
        try
        {
            var json = System.Text.Json.JsonDocument.Parse(body);
            if (json.RootElement.TryGetProperty("message", out var msg))
                return msg.GetString() ?? status.ToString();
        }
        catch { /* ignore */ }
        return status switch
        {
            System.Net.HttpStatusCode.BadRequest => "Invalid request. Check file type and size.",
            System.Net.HttpStatusCode.Unauthorized => "API key invalid or missing.",
            System.Net.HttpStatusCode.Forbidden => "Access denied. Check your OpenAI plan.",
            System.Net.HttpStatusCode.TooManyRequests => "Rate limit or quota exceeded. Check billing.",
            System.Net.HttpStatusCode.InternalServerError => "Server error. Try again later.",
            _ => string.IsNullOrEmpty(body) ? status.ToString() : body
        };
    }

    private void RestoreHistory(HistoryEntry entry)
    {
        _transcription = entry.Transcription;
        _details = entry.Details;
        _stats = BuildStats(entry.Details);
        _durationExceedsRecommended = entry.Details.DurationExceedsRecommended;
        _error = null;
        _actionHint = null;
        StateHasChanged();
    }

    private sealed record HistoryEntry(string FileName, double? DurationSeconds, int WordCount, string Transcription, TranscriptionDetailsView Details);

    private async Task PersistHistoryAsync()
    {
        try
        {
            var list = _history.Select(h => new StoredHistoryItem
            {
                FileName = h.FileName,
                DurationSeconds = h.DurationSeconds,
                WordCount = h.WordCount,
                Transcription = h.Transcription,
                Details = h.Details
            }).ToList();
            var json = System.Text.Json.JsonSerializer.Serialize(list, JsonOptions);
            await Js.InvokeVoidAsync("speechInsight.setLocalStorage", HistoryStorageKey, json);
        }
        catch { /* quota or disabled */ }
    }

    private async Task ClearHistoryAsync()
    {
        _history.Clear();
        try
        {
            await Js.InvokeVoidAsync("speechInsight.setLocalStorage", HistoryStorageKey, "");
        }
        catch { /* ignore */ }
        StateHasChanged();
    }

    private sealed class StoredHistoryItem
    {
        public string FileName { get; set; } = "";
        public double? DurationSeconds { get; set; }
        public int WordCount { get; set; }
        public string Transcription { get; set; } = "";
        public TranscriptionDetailsView? Details { get; set; }
    }

    private static string FormatTranscript(TranscriptionDetailsView details)
    {
        if (details.Segments is { Count: > 0 })
        {
            var speakerMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            var speakerCounter = 0;

            string NormalizeSpeaker(string? raw)
            {
                var key = string.IsNullOrWhiteSpace(raw) ? "unknown" : raw.Trim();
                if (!speakerMap.TryGetValue(key, out var mapped))
                {
                    speakerCounter++;
                    mapped = $"Speaker {speakerCounter}";
                    speakerMap[key] = mapped;
                }
                return mapped;
            }

            var blocks = new List<(string Speaker, string Text)>();
            foreach (var s in details.Segments)
            {
                var t = (s.Text ?? "").Trim();
                if (string.IsNullOrWhiteSpace(t))
                    continue;

                var speaker = NormalizeSpeaker(s.Speaker);

                if (blocks.Count > 0 && blocks[^1].Speaker == speaker)
                {
                    blocks[^1] = (speaker, $"{blocks[^1].Text} {t}".Trim());
                }
                else
                {
                    blocks.Add((speaker, t));
                }
            }

            return string.Join(
                "\n\n",
                blocks.Select(b => $"{b.Speaker}: {b.Text}").Where(x => !string.IsNullOrWhiteSpace(x)));
        }

        return details.Text ?? "";
    }

    private static StatsView BuildStats(TranscriptionDetailsView details)
    {
        var text = details.Text ?? "";
        var words = text.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries).Length;
        return new StatsView(
            DurationSeconds: details.DurationSeconds,
            WordCount: words,
            CharCount: text.Length,
            SegmentCount: details.Segments?.Count ?? 0,
            Diarized: details.Diarized,
            Model: details.Model ?? "—");
    }

    private sealed record StatsView(
        double? DurationSeconds,
        int WordCount,
        int CharCount,
        int SegmentCount,
        bool Diarized,
        string Model);

    private sealed class TranscriptionDetailsView
    {
        public string? Text { get; set; }
        public string? Model { get; set; }
        public double? DurationSeconds { get; set; }
        public List<TranscriptionSegmentView>? Segments { get; set; }
        public bool Diarized { get; set; }
        public bool DurationExceedsRecommended { get; set; }
    }

    private sealed class TranscriptionSegmentView
    {
        public string? Speaker { get; set; }
        public double? StartSeconds { get; set; }
        public double? EndSeconds { get; set; }
        public string? Text { get; set; }
    }

    private async Task CopyTranscript()
    {
        if (string.IsNullOrEmpty(_transcription))
            return;

        _actionHint = null;
        StateHasChanged();
        try
        {
            await Js.InvokeVoidAsync("speechInsight.copyText", _transcription);
            _actionHint = "Copied to clipboard.";
            StateHasChanged();
            _ = Task.Run(async () =>
            {
                await Task.Delay(2500);
                await InvokeAsync(() =>
                {
                    if (_actionHint == "Copied to clipboard.")
                    {
                        _actionHint = null;
                        StateHasChanged();
                    }
                });
            });
        }
        catch
        {
            _actionHint = "Copy failed. Please check browser permissions.";
            StateHasChanged();
        }
    }

    private async Task DownloadTxt()
    {
        if (string.IsNullOrEmpty(_transcription))
            return;

        var baseName = GetSafeBaseFileName(_selectedFile?.Name) ?? "transcription";
        await Js.InvokeVoidAsync("speechInsight.download", $"{baseName}.txt", "text/plain;charset=utf-8", _transcription);
    }

    private async Task DownloadJson()
    {
        if (_details == null)
            return;

        var baseName = GetSafeBaseFileName(_selectedFile?.Name) ?? "transcription";
        var json = System.Text.Json.JsonSerializer.Serialize(_details, new System.Text.Json.JsonSerializerOptions
        {
            WriteIndented = true
        });

        await Js.InvokeVoidAsync("speechInsight.download", $"{baseName}.json", "application/json;charset=utf-8", json);
    }

    private static string? GetSafeBaseFileName(string? fileName)
    {
        if (string.IsNullOrWhiteSpace(fileName))
            return null;

        var name = System.IO.Path.GetFileNameWithoutExtension(fileName);
        foreach (var c in System.IO.Path.GetInvalidFileNameChars())
            name = name.Replace(c, '_');
        return string.IsNullOrWhiteSpace(name) ? "transcription" : name;
    }
}
